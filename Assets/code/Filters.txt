// =============================================================================
// FILTERS BLOCK — Sidechain LPF/HPF (RBJ Butterworth, Q=1) SIN SOLO
// =============================================================================
// ENTRADA:  in1  -> sidechainMixedSignal (mono)
// SALIDAS:  out1 -> sidechain filtrado (para Detector)
//           out2 -> passthrough (opcional/monitor)

// Parámetros
Param j_HPF(20,     min=20,   default=20,    max=20000); // HPF freq (Hz)
Param j_HPFORDER(0, min=0,    default=0,     max=1);     // 0=12 dB/oct, 1=24 dB/oct
Param k_LPF(20000,  min=20,   default=20000, max=20000); // LPF freq (Hz)
Param k_LPFORDER(0, min=0,    default=0,     max=1);     // 0=12 dB/oct, 1=24 dB/oct
Param l_SC(0,       min=0,    default=0,     max=1);     // Enable filtros SC (0: bypass)

// Historias (LPF)
History lpfHist1(0), lpfHist2(0), lpfHist3(0), lpfHist4(0);
History lpfHist5(0), lpfHist6(0), lpfHist7(0), lpfHist8(0);
// Historias (HPF)
History hpfHist1(0), hpfHist2(0), hpfHist3(0), hpfHist4(0);
History hpfHist5(0), hpfHist6(0), hpfHist7(0), hpfHist8(0);
// Historias smoothing de flags
History hpfOrderHist(0);
History lpfOrderHist(0);
History scEnableHist(0);

// Smoothing
smoothHpfOrder = hpfOrderHist * 0.999 + j_HPFORDER * 0.001; hpfOrderHist = fixdenorm(smoothHpfOrder);
smoothLpfOrder = lpfOrderHist * 0.999 + k_LPFORDER * 0.001; lpfOrderHist = fixdenorm(smoothLpfOrder);
smoothScEnable = scEnableHist * 0.999 + l_SC        * 0.001; scEnableHist = fixdenorm(smoothScEnable);

// RBJ Butterworth Q=1 — LPF
omega_lpf = (k_LPF * twopi) / samplerate;
sn_lpf    = sin(omega_lpf);
cs_lpf    = cos(omega_lpf);
alpha_lpf = (sn_lpf * 0.5) / 1.0;
b0_lpf    = 1 / (1 + alpha_lpf);
a0_lpf    = ((1 - cs_lpf) * 0.5) * b0_lpf;
a1_lpf    = (1 - cs_lpf) * b0_lpf;
a2_lpf    = a0_lpf;
b1_lpf    = (-2 * cs_lpf) * b0_lpf;
b2_lpf    = (1 - alpha_lpf) * b0_lpf;

// RBJ Butterworth Q=1 — HPF
omega_hpf = (j_HPF * twopi) / samplerate;
sn_hpf    = sin(omega_hpf);
cs_hpf    = cos(omega_hpf);
alpha_hpf = (sn_hpf * 0.5) / 1.0;
b0_hpf    = 1 / (1 + alpha_hpf);
a0_hpf    = ((1 + cs_hpf) * 0.5) * b0_hpf;
a1_hpf    = (-(1 + cs_hpf)) * b0_hpf;
a2_hpf    = a0_hpf;
b1_hpf    = (-2 * cs_hpf) * b0_hpf;
b2_hpf    = (1 - alpha_hpf) * b0_hpf;

// LPF 12 → 24 dB
lpf1 = (in1 * a0_lpf + lpfHist3 * a1_lpf + lpfHist1 * a2_lpf) - (lpfHist4 * b1_lpf + lpfHist2 * b2_lpf);
lpfHist1 = lpfHist3; lpfHist2 = lpfHist4; lpfHist3 = in1; lpfHist4 = lpf1;

lpf2 = (lpf1 * a0_lpf + lpfHist7 * a1_lpf + lpfHist5 * a2_lpf) - (lpfHist8 * b1_lpf + lpfHist6 * b2_lpf);
lpfHist5 = lpfHist7; lpfHist6 = lpfHist8; lpfHist7 = lpf1; lpfHist8 = lpf2;

lpfOut   = mix(lpf1, lpf2, smoothLpfOrder);
lpfMixed = mix(in1, lpfOut, smoothScEnable);

// HPF 12 → 24 dB
hpf1 = (lpfMixed * a0_hpf + hpfHist3 * a1_hpf + hpfHist1 * a2_hpf) - (hpfHist4 * b1_hpf + hpfHist2 * b2_hpf);
hpfHist1 = hpfHist3; hpfHist2 = hpfHist4; hpfHist3 = lpfMixed; hpfHist4 = hpf1;

hpf2 = (hpf1 * a0_hpf + hpfHist7 * a1_hpf + hpfHist5 * a2_hpf) - (hpfHist8 * b1_hpf + hpfHist6 * b2_hpf);
hpfHist5 = hpfHist7; hpfHist6 = hpfHist8; hpfHist7 = hpf1; hpfHist8 = hpf2;

hpfOut = mix(hpf1, hpf2, smoothHpfOrder);

// Salidas
filtered = hpfOut;
out1 = mix(in1, filtered, smoothScEnable); // señal final para Detector
out2 = in1;                                // passthrough (opcional)
// Funciones
softkneeLinear(xg, T, R, W) {
    _softkneeLinear_ret_1 = 0;
    if((2 * ((xg - T))) < (W * (-1))) {
        _softkneeLinear_ret_1 = xg;
    }
    else if((2 * (abs(xg - T))) <= W) {
        _softkneeLinear_ret_1 = (T - (W / 2)) + ((((((xg - T) + (W / 2))) * ((1 + (1 / R))))) / 2);
    }
    else if((2 * ((xg - T))) > W) {
        _softkneeLinear_ret_1 = T + (((xg - T)) / R);
    }
    return _softkneeLinear_ret_1;
}

// =============================================================================
// PARÁMETROS DEL COMPRESOR
// =============================================================================

// Parámetros principales
Param a_TRIM(-12, min=-12, default=0, max=12);        // Input trim gain (dB)
Param b_THD(-60, min=-60, default=-18, max=0);        // Threshold (dB)
Param c_RATIO(1, min=1, default=4, max=20);           // Compression ratio
Param d_ATK(0.1, min=0.1, default=5, max=250);       // Attack time (ms)
Param e_REL(0.1, min=0.1, default=30, max=1000);     // Release time (ms)
Param i_MAKEUP(-12, min=-12, default=0, max=12);      // Makeup gain (dB)
Param h_KNEE(0, min=0, default=0, max=30);            // Knee width (dB)

// Algoritmos y detección
Param f_ALGO(0, min=0, default=1, max=2);             // Detection algorithm (0=Sharp, 1=Classic, 2=Slow)
Param g_REACT(0, min=0, default=0, max=1);            // Peak/RMS mix (0=Peak, 1=RMS)
Param z_SMOOTH(0, min=0, default=0, max=1);           // Extra smoothing amount

// Filtros de sidechain
Param j_HPF(20, min=20, default=20, max=20000);       // Sidechain HPF frequency (Hz)
Param j_HPFORDER(0, min=0, default=0, max=1);         // HPF order (0=12dB/oct, 1=24dB/oct)
Param k_LPF(20, min=20, default=20000, max=20000);    // Sidechain LPF frequency (Hz)
Param k_LPFORDER(0, min=0, default=0, max=1);         // LPF order (0=12dB/oct, 1=24dB/oct)
Param l_SC(0, min=0, default=0, max=1);               // Sidechain filter enable
Param y_SCTRIM(-12, min=-12, default=0, max=12);      // Sidechain input trim (dB)

// Routing y mezcla
Param r_KEY(0, min=0, default=0, max=1);              // External key input mix
Param m_SOLOSC(0, min=0, default=0, max=1);           // Solo sidechain signal
Param o_DRYWET(0, min=0, default=1, max=1);           // Dry/Wet mix (0=Dry, 1=Wet)
Param w_PARALLEL(0, min=0, default=0, max=1);         // Parallel compression amount
Param v_DELTA(0, min=0, default=0, max=1);            // Delta mode (difference signal)

// Características avanzadas
Param n_LOOKAHEAD(0, min=0, default=0, max=10);       // Lookahead time (ms)
Param s_AUTORELEASE(0, min=0, default=0, max=1);      // Auto release enable (simplificado)
Param x_AUTOGAIN(0, min=0, default=0, max=1);         // Auto makeup gain enable
Param u_SOFTCLIP(0, min=0, default=0, max=1);         // Output saturation amount (0=Off, 1=Full)

// Control
Param p_BYPASS(0, min=0, default=0, max=1);           // Bypass switch

// =============================================================================
// HISTORIAS Y DELAYS
// =============================================================================

// Historias para smoothing de parámetros
History parallelMixHistory(0);         // Para parallel compression amount
History deltaModeHistory(0);           // Para delta mode amount
History autoGainHistory(0);            // Para auto makeup gain enable
History thresholdHistory(0);           // Para threshold value
History makeupGainHistory(0);          // Para makeup gain amount
History soloSidechainHistory(0);       // Para solo sidechain amount
History bypassAmountHistory(0);        // Para bypass amount
History keyMixHistory(0);              // Para key input mix
History dryWetMixHistory(0);           // Para dry/wet mix
History trimHistory(0);                // Para input trim gain
History sidechainTrimHistory(0);       // Para sidechain trim gain

// Historias adicionales para smoothing de parámetros
History ratioHistory(0);              // Para compression ratio
History kneeHistory(0);               // Para knee width
History reactHistory(0);              // Para peak/RMS mix
History smoothAmountHistory(0);       // Para extra smoothing
History lookaheadHistory(0);          // Para lookahead (con factor especial)
History hpfFreqHistory(0);            // Para HPF frequency
History lpfFreqHistory(0);            // Para LPF frequency
History scEnableHistory(0);           // Para sidechain filter enable
History softclipHistory(0);           // Para softclip amount
History atkHistory(0);                // Para attack time
History relHistory(0);                // Para release time

// Historias para filtros de sidechain
History lpfHistory1(0);                // LPF stage 1 input delay
History lpfHistory2(0);                // LPF stage 1 output delay z^-1
History lpfHistory3(0);                // LPF stage 1 input z^-1
History lpfHistory4(0);                // LPF stage 1 output z^-2
History lpfHistory5(0);                // LPF stage 2 input delay
History lpfHistory6(0);                // LPF stage 2 output delay z^-1
History lpfHistory7(0);                // LPF stage 2 input z^-1
History lpfHistory8(0);                // LPF stage 2 output z^-2
History hpfHistory1(0);                // HPF stage 1 output delay z^-1
History hpfHistory2(0);                // HPF stage 1 input delay
History hpfHistory3(0);                // HPF stage 1 input z^-1
History hpfHistory4(0);                // HPF stage 1 output z^-2
History hpfHistory5(0);                // HPF stage 2 output delay z^-1
History hpfHistory6(0);                // HPF stage 2 input delay
History hpfHistory7(0);                // HPF stage 2 input z^-1
History hpfHistory8(0);                // HPF stage 2 output z^-2

// Historias para smoothing de orden de filtros
History hpfOrderHistory(0);            // Para suavizar cambio de orden HPF
History lpfOrderHistory(0);            // Para suavizar cambio de orden LPF

// Nueva historia para detección de transientes (auto-release simplificado)
History transientDetector(0);          // Detector de transientes acumulado

// Delays de lookahead (25ms a 48kHz = 1200 muestras)
Delay leftOutputDelay(0.025*samplerate);   // Delay señal izquierda para compresión
Delay rightOutputDelay(0.025*samplerate);  // Delay señal derecha para compresión
Delay leftInputDelay(0.025*samplerate);    // Delay entrada izquierda para mezcla
Delay rightInputDelay(0.025*samplerate);   // Delay entrada derecha para mezcla
Delay sidechainTapDelay(0.025*samplerate); // Delay para tap de sidechain
Delay sidechainWriteDelay(0.025*samplerate); // Delay para escritura de sidechain

// =============================================================================
// VARIABLES DE DETECCIÓN DE ENVOLVENTE
// =============================================================================

// RMS Detection Buffer
Delay rmsDelay(500);                   // Circular buffer para cálculo RMS (500 muestras)
History rmsSum(0);                     // Suma acumulada para RMS
History prevEnvelope(0);               // Envolvente anterior para auto-release

// Sharp Detector (Algoritmo 0) - Respuesta rápida
History peakEnvSharp(0);               // Detector de picos rápido
History releaseHistSharp(0);           // Historia de release para sharp
History attackHistSharp(0);            // Historia de attack para sharp
History extraSmoothHistSharp(0);       // Extra smoothing para sharp

// Classic Detector (Algoritmo 1) - Respuesta equilibrada
History peakEnvClassic(0);             // Detector de picos clásico
History rmsSqClassic(0);               // Suma cuadrática RMS clásico
History histRmsClassic(0);             // Historia RMS clásico
History releaseHistClassic(0);         // Historia de release para classic
History attackHistClassic(0);          // Historia de attack para classic
History extraSmoothHistClassic(0);     // Extra smoothing para classic

// Slow Detector (Algoritmo 2) - Respuesta suave
History peakEnvSlow(0);                // Detector de picos lento
History rmsSqSlow(0);                  // Suma cuadrática RMS lento
History histRmsSlow(0);                // Historia RMS lento
History releaseHistSlow(0);            // Historia de release para slow
History attackHistSlow(0);             // Historia de attack para slow
History extraSmoothHistSlow(0);        // Extra smoothing para slow

// Gain Reduction Smoothing
History reductionHistLeft(0);          // Suavizado de gain reduction canal L
History reductionHistRight(0);         // Suavizado de gain reduction canal R

// =============================================================================
// VARIABLES DE SALIDA Y CONSTANTES
// =============================================================================

// Variables para almacenar las salidas procesadas
leftProcessedOutput = 0;               // Salida procesada canal izquierdo
rightProcessedOutput = 0;              // Salida procesada canal derecho

// Constantes para optimización y legibilidad
SMOOTH_HISTORY_FACTOR = 0.999;         // Factor de suavizado para valores históricos (99.9%)
SMOOTH_PARAM_FACTOR = 0.001;           // Factor de suavizado para nuevos parámetros (0.1%)
AUTO_MAKEUP_FACTOR = -0.7;             // Factor de compensación automática de ganancia
LOOKAHEAD_DELAY_SAMPLES = 0.025*samplerate; // Muestras de delay para lookahead

// PROCESAMIENTO PRINCIPAL

// =============================================================================
// SMOOTHING DE PARÁMETROS - Filtro de primer orden para evitar clicks
// =============================================================================
// Implementación: y[n] = a * x[n] + (1-a) * y[n-1]
// Donde: a = SMOOTH_PARAM_FACTOR (0.001), (1-a) = SMOOTH_HISTORY_FACTOR (0.999)
// Resultado: Suavizado exponencial con tiempo de respuesta ~1000 muestras

// Parallel Mix Amount - Cantidad de compresión paralela
smoothParallelMix = (parallelMixHistory * SMOOTH_HISTORY_FACTOR) + (w_PARALLEL * SMOOTH_PARAM_FACTOR);
parallelMixHistoryNext = fixdenorm(smoothParallelMix);

// Delta Mode Amount - Cantidad de señal diferencia (experimental)
smoothDeltaMode = (deltaModeHistory * SMOOTH_HISTORY_FACTOR) + (v_DELTA * SMOOTH_PARAM_FACTOR);
deltaModeHistoryNext = fixdenorm(smoothDeltaMode);

// Auto Gain Enable - Activación de makeup gain automático
smoothAutoGain = (autoGainHistory * SMOOTH_HISTORY_FACTOR) + (x_AUTOGAIN * SMOOTH_PARAM_FACTOR);
autoGainHistoryNext = fixdenorm(smoothAutoGain);

// =============================================================================
// IMPLEMENTACIÓN DELTA MODE - Bypass automático de procesamiento posterior
// =============================================================================
// Cuando DELTA está activo, se bypasean automáticamente:
// - Auto Gain: se fuerza a 0 (solo makeup manual)
// - Parallel Compression: se fuerza a 0 (sin compresión paralela)
// - Dry/Wet: se fuerza a 1 (100% wet)
// Esto permite escuchar SOLO la señal diferencia sin amplificaciones posteriores

// Crear valores de bypass cuando DELTA está activo
deltaBypassValue = int(0);  // Valor para forzar auto gain y parallel a 0
deltaWetValue = int(1);     // Valor para forzar dry/wet a 100% wet

// Aplicar bypass condicional basado en DELTA
effectiveAutoGain = mix(smoothAutoGain, deltaBypassValue, smoothDeltaMode);
effectiveParallelMix = mix(smoothParallelMix, deltaBypassValue, smoothDeltaMode);

// Threshold Level - Umbral de compresión en dB
smoothThresholdDb = (thresholdHistory * SMOOTH_HISTORY_FACTOR) + (b_THD * SMOOTH_PARAM_FACTOR);
thresholdHistoryNext = fixdenorm(smoothThresholdDb);

// Filter Order Smoothing - Suavizado de orden de filtros
smoothHpfOrder = (hpfOrderHistory * SMOOTH_HISTORY_FACTOR) + (j_HPFORDER * SMOOTH_PARAM_FACTOR);
hpfOrderHistoryNext = fixdenorm(smoothHpfOrder);
smoothLpfOrder = (lpfOrderHistory * SMOOTH_HISTORY_FACTOR) + (k_LPFORDER * SMOOTH_PARAM_FACTOR);
lpfOrderHistoryNext = fixdenorm(smoothLpfOrder);

// Ratio Smoothing
smoothRatio = (ratioHistory * SMOOTH_HISTORY_FACTOR) + (c_RATIO * SMOOTH_PARAM_FACTOR);
ratioHistoryNext = fixdenorm(smoothRatio);

// Knee Smoothing
smoothKnee = (kneeHistory * SMOOTH_HISTORY_FACTOR) + (h_KNEE * SMOOTH_PARAM_FACTOR);
kneeHistoryNext = fixdenorm(smoothKnee);

// React (Peak/RMS) Smoothing
smoothReact = (reactHistory * SMOOTH_HISTORY_FACTOR) + (g_REACT * SMOOTH_PARAM_FACTOR);
reactHistoryNext = fixdenorm(smoothReact);

// Extra Smooth Amount Smoothing
smoothSmoothAmount = (smoothAmountHistory * SMOOTH_HISTORY_FACTOR) + (z_SMOOTH * SMOOTH_PARAM_FACTOR);
smoothAmountHistoryNext = fixdenorm(smoothSmoothAmount);

// Attack Time Smoothing
smoothAttack = (atkHistory * SMOOTH_HISTORY_FACTOR) + (d_ATK * SMOOTH_PARAM_FACTOR);
atkHistoryNext = fixdenorm(smoothAttack);

// Release Time Smoothing
smoothRelease = (relHistory * SMOOTH_HISTORY_FACTOR) + (e_REL * SMOOTH_PARAM_FACTOR);
relHistoryNext = fixdenorm(smoothRelease);

// HPF Frequency Smoothing
smoothHpfFreq = (hpfFreqHistory * SMOOTH_HISTORY_FACTOR) + (j_HPF * SMOOTH_PARAM_FACTOR);
hpfFreqHistoryNext = fixdenorm(smoothHpfFreq);

// LPF Frequency Smoothing
smoothLpfFreq = (lpfFreqHistory * SMOOTH_HISTORY_FACTOR) + (k_LPF * SMOOTH_PARAM_FACTOR);
lpfFreqHistoryNext = fixdenorm(smoothLpfFreq);

// Sidechain Enable Smoothing
smoothScEnable = (scEnableHistory * SMOOTH_HISTORY_FACTOR) + (l_SC * SMOOTH_PARAM_FACTOR);
scEnableHistoryNext = fixdenorm(smoothScEnable);

// Softclip Amount Smoothing
smoothSoftclip = (softclipHistory * SMOOTH_HISTORY_FACTOR) + (u_SOFTCLIP * SMOOTH_PARAM_FACTOR);
softclipHistoryNext = fixdenorm(smoothSoftclip);

// Lookahead sin smoothing en Gen: JUCE se encarga de la gestión
smoothLookahead = n_LOOKAHEAD;                 // directo, sin 0.001/0.999
lookaheadHistoryNext = fixdenorm(smoothLookahead);

// Cuantizar a muestras enteras (consistencia con setLatencySamples en host)
lookaheadSamples = round(mstosamps(smoothLookahead));

// ==== PRE-WRITE para feedback=0 real ====
// (mismo smoothing de trim que usas luego)
smoothTrimGain = (trimHistory * SMOOTH_HISTORY_FACTOR) + (a_TRIM * SMOOTH_PARAM_FACTOR);
trimHistoryNext = fixdenorm(smoothTrimGain);
trimGainLinear = dbtoa(smoothTrimGain);

// Señales con trim para rama de compresión
leftTrimmed  = in1 * trimGainLinear;
rightTrimmed = in2 * trimGainLinear;

// Escribir SIEMPRE antes de leer (evita +1 muestra intrínseca)
leftInputDelay.write(in1);              // sin trim para DRY
rightInputDelay.write(in2);
leftOutputDelay.write(leftTrimmed);     // con trim para compresión
rightOutputDelay.write(rightTrimmed);

// =============================================================================
// LOOKAHEAD DELAY SYSTEM - Sistema de delay predictivo
// =============================================================================
// El lookahead permite al compresor "ver" la señal antes de que llegue,
// evitando transientes que causen overshooting. Las señales de audio se retrasan
// mientras que la detección trabaja con la señal sin retrasar.

// Convertir tiempo de lookahead (ms) a muestras
lookaheadSamples = mstosamps(smoothLookahead);

// Leer señales retrasadas para compresión (delayed audio)
leftDelayedForCompression = leftOutputDelay.read(lookaheadSamples, interp="step");
rightDelayedForCompression = rightOutputDelay.read(lookaheadSamples, interp="step");

// Asignar salidas de medidores principales (señales que entran a la compresión)
out4 = leftDelayedForCompression;
out5 = rightDelayedForCompression;

// Leer señales retrasadas para mezcla final (las escrituras se hacen más abajo después del trim)
leftDelayedForMixing = leftInputDelay.read(lookaheadSamples, interp="step");
rightDelayedForMixing = rightInputDelay.read(lookaheadSamples, interp="step");

// =============================================================================
// MAKEUP GAIN Y SIDECHAIN TAPS
// =============================================================================

// Makeup Gain - Ganancia de compensación
smoothMakeupGain = (makeupGainHistory * SMOOTH_HISTORY_FACTOR) + (i_MAKEUP * SMOOTH_PARAM_FACTOR);
makeupGainHistoryNext = fixdenorm(smoothMakeupGain);
// Duplicar valor para uso en canales L y R
leftMakeupGain = smoothMakeupGain;
rightMakeupGain = leftMakeupGain;

// Sidechain Tap - Señal retrasada para procesamiento de sidechain
sidechainDelayedTap = sidechainTapDelay.read(lookaheadSamples, interp="step");

// Solo Sidechain - Monitoreo de señal de sidechain
smoothSoloSidechain = (soloSidechainHistory * SMOOTH_HISTORY_FACTOR) + (m_SOLOSC * SMOOTH_PARAM_FACTOR);
soloSidechainHistoryNext = fixdenorm(smoothSoloSidechain);

// Sidechain Write Tap - Señal retrasada para escritura
sidechainDelayedWrite = sidechainWriteDelay.read(lookaheadSamples, interp="step");

// =============================================================================
// CONTROL PARAMS - Parámetros de control y bypass
// =============================================================================

// Bypass - Activación/desactivación del efecto
bypassInverted = 1 - p_BYPASS;               // Invertir lógica (1=activo, 0=bypass)
smoothBypassAmount = (bypassAmountHistory * SMOOTH_HISTORY_FACTOR) + (bypassInverted * SMOOTH_PARAM_FACTOR);
bypassAmountHistoryNext = fixdenorm(smoothBypassAmount);

// Key Mix - Mezcla entre señal principal y external key
smoothKeyMix = (keyMixHistory * SMOOTH_HISTORY_FACTOR) + (r_KEY * SMOOTH_PARAM_FACTOR);
keyMixHistoryNext = fixdenorm(smoothKeyMix);

// Dry/Wet Mix - Balance entre señal original y procesada
smoothDryWetMix = (dryWetMixHistory * SMOOTH_HISTORY_FACTOR) + (o_DRYWET * SMOOTH_PARAM_FACTOR);
dryWetMixHistoryNext = fixdenorm(smoothDryWetMix);

// Aplicar bypass de dry/wet cuando DELTA está activo
effectiveDryWetMix = mix(smoothDryWetMix, deltaWetValue, smoothDeltaMode);

// =============================================================================
// INPUT PROCESSING - Procesamiento de entradas con trim
// =============================================================================
// Trim Principal - Ganancia de entrada
smoothTrimGain = (trimHistory * SMOOTH_HISTORY_FACTOR) + (a_TRIM * SMOOTH_PARAM_FACTOR);
trimHistoryNext = fixdenorm(smoothTrimGain);
trimGainLinear = dbtoa(smoothTrimGain);

// Aplicar trim a entradas
leftTrimmed = in1 * trimGainLinear;
rightTrimmed = in2 * trimGainLinear;

// Escribir señales en delays (comentando para que surta efecto PRE-WRITE para feedback=0 real)
//leftInputDelay.write(in1);          // Sin trim para bypass/dry
//rightInputDelay.write(in2);         // Sin trim para bypass/dry
//leftOutputDelay.write(leftTrimmed); // Con trim para compresión
//rightOutputDelay.write(rightTrimmed); // Con trim para compresión

// Crear señal mono de entrada principal
mainSignalMono = ((rightTrimmed + leftTrimmed)) * 0.707;  // Suma mono de entrada principal
trimGainReference = trimGainLinear;           // Referencia para normalización posterior

// Sidechain Trim - Ganancia de entrada de sidechain
smoothSidechainTrimGain = (sidechainTrimHistory * SMOOTH_HISTORY_FACTOR) + (y_SCTRIM * SMOOTH_PARAM_FACTOR);
sidechainTrimHistoryNext = fixdenorm(smoothSidechainTrimGain);
sidechainTrimGainLinear = dbtoa(smoothSidechainTrimGain);
sidechainTrimReference = sidechainTrimGainLinear;  // Referencia para uso posterior

// Aplicar trim a entradas de sidechain
leftSidechainTrimmed = in3 * sidechainTrimReference;
rightSidechainTrimmed = in4 * sidechainTrimReference;

// Asignar salidas de sidechain (sin delay por ahora)
out6 = leftSidechainTrimmed;
out7 = rightSidechainTrimmed;

// Crear señal mono de sidechain
sidechainSignalMono = ((rightSidechainTrimmed + leftSidechainTrimmed)) * 0.707;  // Suma mono de sidechain

// Key mixing - Mezcla entre señal principal y external key input
keyMixedSignal = mix(mainSignalMono, sidechainSignalMono, smoothKeyMix);

// Control params asignados directamente
ONSIDECHAIN = smoothScEnable;
ALGO = f_ALGO;
REACT = smoothReact;
AUTO_RELEASE = s_AUTORELEASE;  // Directo, sin SPEED
EXTRA_SMOOTH = smoothSmoothAmount;

// =============================================================================
// FILTROS DE SIDECHAIN - BIQUAD BUTTERWORTH (Robert Bristow-Johnson)
// =============================================================================
// Implementación de filtros biquad de 2º orden (12 dB/oct) con opción de
// cascadear para 4º orden (24 dB/oct). Transición suave entre órdenes.
// Basado en las fórmulas de Robert Bristow-Johnson's Audio EQ Cookbook

// Q factor para respuesta Butterworth (maximally flat)
BUTTERWORTH_Q = 1.0;                         // Q = 1 para respuesta plana sin resonancia

// Coeficientes LPF Butterworth de 2º orden
omega = ((smoothLpfFreq * twopi)) / samplerate;   // Frecuencia normalizada
sn = sin(omega);
cs = cos(omega);
one_over_Q = 1 / BUTTERWORTH_Q;              // Inverso del Q factor
alpha = ((sn * 0.5)) * one_over_Q;
b0 = 1 / ((1 + alpha));                     // Normalización
a2 = ((((1 - cs)) * 0.5)) * b0;             // Coeficiente feedforward z^-2
a1 = ((1 - cs)) * b0;                       // Coeficiente feedforward z^-1
b1 = ((-2 * cs)) * b0;                      // Coeficiente feedback z^-1
b2 = ((1 - alpha)) * b0;                    // Coeficiente feedback z^-2

// Asignar coeficientes LPF
lpfCoeffA2 = a2;
lpfCoeffA1 = a1;
lpfCoeffA0 = a2;  // a0 = a2 para LPF simétrico
lpfCoeffB1 = b1;
lpfCoeffB2 = b2;

// Coeficientes HPF Butterworth de 2º orden
omega_hpf = ((smoothHpfFreq * twopi)) / samplerate;
sn_hpf = sin(omega_hpf);
cs_hpf = cos(omega_hpf);
alpha_hpf = ((sn_hpf * 0.5)) / BUTTERWORTH_Q;  // Usar mismo Q factor
b0_hpf = 1 / ((1 + alpha_hpf));
a_hpf = ((((1 + cs_hpf)) * 0.5)) * b0_hpf;   // Coeficiente feedforward
a_neg_hpf = (-(1 + cs_hpf)) * b0_hpf;       // Coeficiente feedforward negativo
b1_hpf = ((-2 * cs_hpf)) * b0_hpf;
b2_hpf = ((1 - alpha_hpf)) * b0_hpf;

// Asignar coeficientes HPF
hpfCoeffA2 = a_hpf;
hpfCoeffA1 = a_neg_hpf;
hpfCoeffA0 = a_hpf;  // a0 = a2 para HPF simétrico
hpfCoeffB1 = b1_hpf;
hpfCoeffB2 = b2_hpf;

// Pre-procesar señal de sidechain
sidechainMixedSignal = keyMixedSignal * 0.707;

// =============================================================================
// LPF - FILTRO PASO BAJO CON OPCIÓN 12/24 dB/oct
// =============================================================================

// Primera etapa LPF (12 dB/oct)
lpfInput = sidechainMixedSignal * lpfCoeffA2;
lpfFromHistory1 = lpfHistory3 * lpfCoeffA1;
lpfFromHistory2 = lpfHistory1 * lpfCoeffA0;
lpfFeedback1 = lpfHistory2 * lpfCoeffB2;
lpfFeedback2 = lpfHistory4 * lpfCoeffB1;
lpfFilteredSignal = ((((lpfFromHistory2 + lpfFromHistory1)) + lpfInput)) - ((lpfFeedback2 + lpfFeedback1));

// Actualizar historias LPF primera etapa
lpfHistory1Next = fixdenorm(lpfHistory3);
lpfHistory2Next = fixdenorm(lpfHistory4);
lpfHistory3Next = fixdenorm(sidechainMixedSignal);
lpfHistory4Next = fixdenorm(lpfFilteredSignal);

// Segunda etapa LPF (para 24 dB/oct)
lpfStage2Input = lpfFilteredSignal * lpfCoeffA2;
lpfStage2FromHistory1 = lpfHistory7 * lpfCoeffA1;
lpfStage2FromHistory2 = lpfHistory5 * lpfCoeffA0;
lpfStage2Feedback1 = lpfHistory6 * lpfCoeffB2;
lpfStage2Feedback2 = lpfHistory8 * lpfCoeffB1;
lpfStage2FilteredSignal = ((((lpfStage2FromHistory2 + lpfStage2FromHistory1)) + lpfStage2Input)) - ((lpfStage2Feedback2 + lpfStage2Feedback1));

// Actualizar historias LPF segunda etapa
lpfHistory5Next = fixdenorm(lpfHistory7);
lpfHistory6Next = fixdenorm(lpfHistory8);
lpfHistory7Next = fixdenorm(lpfFilteredSignal);
lpfHistory8Next = fixdenorm(lpfStage2FilteredSignal);

// Mezclar entre 12dB/oct y 24dB/oct según smoothLpfOrder
lpfFinalSignal = mix(lpfFilteredSignal, lpfStage2FilteredSignal, smoothLpfOrder);

// Mezclar señal directa con LPF según ONSIDECHAIN
lpfMixedSignal = mix(sidechainMixedSignal, lpfFinalSignal, ONSIDECHAIN);

// =============================================================================
// HPF - FILTRO PASO ALTO CON OPCIÓN 12/24 dB/oct
// =============================================================================

// Primera etapa HPF (12 dB/oct)
hpfInput = lpfMixedSignal * hpfCoeffA2;
hpfFromHistory1 = hpfHistory3 * hpfCoeffA1;
hpfFromHistory2 = hpfHistory2 * hpfCoeffA0;
hpfFeedback1 = hpfHistory1 * hpfCoeffB2;
hpfFeedback2 = hpfHistory4 * hpfCoeffB1;
hpfFilteredSignal = ((((hpfFromHistory2 + hpfFromHistory1)) + hpfInput)) - ((hpfFeedback2 + hpfFeedback1));

// Actualizar historias HPF primera etapa
hpfHistory1Next = fixdenorm(hpfHistory4);
hpfHistory2Next = fixdenorm(hpfHistory3);
hpfHistory3Next = fixdenorm(lpfMixedSignal);
hpfHistory4Next = fixdenorm(hpfFilteredSignal);

// Segunda etapa HPF (para 24 dB/oct)
hpfStage2Input = hpfFilteredSignal * hpfCoeffA2;
hpfStage2FromHistory1 = hpfHistory7 * hpfCoeffA1;
hpfStage2FromHistory2 = hpfHistory6 * hpfCoeffA0;
hpfStage2Feedback1 = hpfHistory5 * hpfCoeffB2;
hpfStage2Feedback2 = hpfHistory8 * hpfCoeffB1;
hpfStage2FilteredSignal = ((((hpfStage2FromHistory2 + hpfStage2FromHistory1)) + hpfStage2Input)) - ((hpfStage2Feedback2 + hpfStage2Feedback1));

// Actualizar historias HPF segunda etapa
hpfHistory5Next = fixdenorm(hpfHistory8);
hpfHistory6Next = fixdenorm(hpfHistory7);
hpfHistory7Next = fixdenorm(hpfFilteredSignal);
hpfHistory8Next = fixdenorm(hpfStage2FilteredSignal);

// Mezclar entre 12dB/oct y 24dB/oct según smoothHpfOrder
hpfFinalSignal = mix(hpfFilteredSignal, hpfStage2FilteredSignal, smoothHpfOrder);

// Mezclar señal con HPF según ONSIDECHAIN y obtener señal final de sidechain
sidechainProcessedSignal = mix(lpfMixedSignal, hpfFinalSignal, ONSIDECHAIN);
sidechainDetectionSignal = sidechainProcessedSignal;

// =============================================================================
// DETECCIÓN DE ENVOLVENTE - Sistema híbrido de 3 algoritmos
// =============================================================================
// Los algoritmos y su hibridación han sido elegidos empíricamente por oído

// Detección de envolvente - Preparación de coeficientes
attack_ms = max(0.05, smoothAttack);
release_ms = max(0.1, smoothRelease);
attack_coeff = exp(-1 / ((((attack_ms * samplerate)) * 0.001)));

// =============================================================================
// NUEVO SISTEMA AUTO-RELEASE SIMPLIFICADO
// =============================================================================
current_signal_abs = abs(sidechainDetectionSignal);
signal_change = abs(current_signal_abs - prevEnvelope);

// Declarar la variable antes del condicional
final_release_time = release_ms;  // Por defecto usar release manual

if(AUTO_RELEASE > 0.5) {
    // Sistema automático activado
    
    // 1. Detección mejorada de transientes
    // Usar un umbral relativo al nivel actual para mejor detección
    relative_threshold = max(0.01, current_signal_abs * 0.3);  // 30% del nivel actual
    is_transient = signal_change > relative_threshold ? 1 : 0;
    
    // 2. Acumulador más rápido para mejor respuesta
    // Usar diferentes velocidades para subida y bajada
    program_smooth = 0.995;  // Valor por defecto
    if(is_transient > 0.5) {
        // Transiente detectado - respuesta rápida
        program_smooth = 0.95;  // ~20 muestras para detectar percusivo
    }
    
    transientDetector = (transientDetector * program_smooth) + (is_transient * (1 - program_smooth));
    
    // 3. Rangos de release ajustados con curva no lineal
    // Usar pow() para hacer la transición más musical
    transient_shaped = pow(transientDetector, 1.5);  // Curva exponencial para más separación
    percussive_release = 15;     // 15ms para material muy percusivo
    sustained_release = 500;     // 500ms para material sostenido
    
    // 4. Interpolación basada en el contenido detectado
    base_release = mix(sustained_release, percussive_release, transient_shaped);
    
    // 5. Modulación dinámica mejorada
    // Considerar tanto el cambio como el nivel absoluto
    level_factor = scale(current_signal_abs, 0, 0.5, 1, 0.6, 1);  // Señales fuertes = release más rápido
    change_factor = scale(signal_change, 0, 0.2, 1, 0.4, 1);      // Cambios grandes = release más rápido
    instant_mod = min(level_factor, change_factor);               // Usar el más agresivo
    
    // 6. Release final
    final_release_time = base_release * instant_mod;
    
    // 7. Límites de seguridad con histéresis suave
    // Evitar cambios bruscos entre samples consecutivos
    release_change_limit = 0.7;  // Máximo 70% de cambio entre samples
    if(prevEnvelope > 0) {
        max_change = final_release_time * release_change_limit;
        final_release_time = clamp(final_release_time,
                                  prevEnvelope - max_change,
                                  prevEnvelope + max_change);
    }
    final_release_time = clamp(final_release_time, 10, 600);
}

// Calcular coeficiente de release
release_coeff = exp(-1 / ((((final_release_time * samplerate)) * 0.001)));

// Actualizar historia para siguiente sample
prevEnvelope = current_signal_abs;

// =============================================================================
// RMS SHARP (para ALGO 0) - Sliding RMS con ventana corta
// =============================================================================
rms_window = max(1, floor(25 * (samplerate / 48000)));  // Escalar ventana por SR
rms_window_inv = 1 / rms_window;                        // Precalcular inverso
input_squared = sidechainDetectionSignal * sidechainDetectionSignal;
oldest_sq = rmsDelay.read(rms_window, interp="none");   // Leer muestra más antigua
rms_sum_new = ((input_squared + rmsSum)) - oldest_sq;   // Cálculo incremental
rms_sum_clipped = max(0, rms_sum_new);                  // Evitar valores negativos
rms_value_sharp = sqrt(rms_sum_clipped * rms_window_inv); // RMS final
rmsSum = rms_sum_clipped;                               // Actualizar suma
rmsDelay.write(input_squared);                          // Escribir nueva muestra

// =============================================================================
// ALGORITMO 0: SHARP DETECTOR - Respuesta rápida y precisa
// =============================================================================
peakEnvSharp = abs(sidechainDetectionSignal);           // Detección de pico instantánea
env_mix_sharp = mix(peakEnvSharp, rms_value_sharp, REACT); // Peak/RMS según REACT
release_env_175 = releaseHistSharp * release_coeff;     // Aplicar release
env_post_release_176 = max(env_mix_sharp, release_env_175); // Solo decay, no attack en release
attack_env_177 = attackHistSharp * attack_coeff;       // Historia de attack
attack_mix_178 = (((1 - attack_coeff)) * env_post_release_176) + (attack_coeff * attack_env_177); // Mezcla attack
sharpEnvelopeFinal = max(attack_mix_178, 1e-06);       // Evitar valores nulos
releaseHistSharp = fixdenorm(env_post_release_176);     // Actualizar historia release
attackHistSharp = fixdenorm(attack_mix_178);           // Actualizar historia attack

// =============================================================================
// ALGORITMO 1: CLASSIC DETECTOR - Comportamiento tradicional
// =============================================================================
input_abs_classic = abs(sidechainDetectionSignal);     // Señal absoluta para Peak
rms_coeff = exp(-1 / ((((50 * samplerate)) * 0.001))); // RMS fijo: 50ms

// Detector de picos con attack/release separados
if(input_abs_classic > peakEnvClassic) {
    peakEnvClassic = (((1 - attack_coeff)) * input_abs_classic) + (attack_coeff * peakEnvClassic);
}
else {
    peakEnvClassic = (((1 - release_coeff)) * input_abs_classic) + (release_coeff * peakEnvClassic);
}

// RMS exponencial independiente
input_sq_classic = sidechainDetectionSignal * sidechainDetectionSignal;
rmsSqClassic = (rmsSqClassic * rms_coeff) + (input_sq_classic * ((1 - rms_coeff))); // RMS cuadrático
rms_env_classic_raw = sqrt(rmsSqClassic);              // Raíz cuadrada = RMS real

// Envolvente para RMS con attack/release propios
if(rms_env_classic_raw > histRmsClassic) {
    histRmsClassic = (((1 - attack_coeff)) * rms_env_classic_raw) + (attack_coeff * histRmsClassic);
}
else {
    histRmsClassic = (((1 - release_coeff)) * rms_env_classic_raw) + (release_coeff * histRmsClassic);
}

env_mix_classic = mix(peakEnvClassic, histRmsClassic, REACT); // Peak/RMS según REACT

// =============================================================================
// ALGORITMO 2: SLOW DETECTOR - Respuesta suave y musical
// =============================================================================
input_abs_slow = abs(sidechainDetectionSignal);        // Señal absoluta para Peak
rms_coeff_slow = exp(-1 / ((((200 * samplerate)) * 0.001))); // RMS lento: 200ms

// Detector de picos con attack/release separados
if(input_abs_slow > peakEnvSlow) {
    peakEnvSlow = (((1 - attack_coeff)) * input_abs_slow) + (attack_coeff * peakEnvSlow);
}
else {
    peakEnvSlow = (((1 - release_coeff)) * input_abs_slow) + (release_coeff * peakEnvSlow);
}

// RMS exponencial lento
input_sq_slow = sidechainDetectionSignal * sidechainDetectionSignal;
rmsSqSlow = (rmsSqSlow * rms_coeff_slow) + (input_sq_slow * ((1 - rms_coeff_slow))); // RMS cuadrático
rms_env_slow_raw = sqrt(rmsSqSlow);                    // Raíz cuadrada = RMS real

// Envolvente para RMS con attack/release propios
if(rms_env_slow_raw > histRmsSlow) {
    histRmsSlow = (((1 - attack_coeff)) * rms_env_slow_raw) + (attack_coeff * histRmsSlow);
}
else {
    histRmsSlow = (((1 - release_coeff)) * rms_env_slow_raw) + (release_coeff * histRmsSlow);
}

env_mix_slow = mix(peakEnvSlow, histRmsSlow, REACT);   // Peak/RMS según REACT

// =============================================================================
// EXTRA SMOOTHING POST-DETECCIÓN - Suavizado adicional configurable
// =============================================================================
smooth_amount_shaped = pow(EXTRA_SMOOTH, 2.5);         // Curva exponencial para control musical
smooth_time_ms = mix(0.001, 100, smooth_amount_shaped); // Mapeo a rango temporal
extra_smooth_coeff = exp(-1 / ((((smooth_time_ms * samplerate)) * 0.001))); // Coeficiente de filtro

// Algoritmo 0 - Salida en dB con smoothing opcional
expr_algo0 = atodb(sharpEnvelopeFinal);               // Conversión a dB base
if(EXTRA_SMOOTH >= 0.001) {                           // Solo si hay smoothing significativo
    extraSmoothedSharpEnv = (extraSmoothHistSharp * extra_smooth_coeff) + (sharpEnvelopeFinal * ((1 - extra_smooth_coeff)));
    extraSmoothHistSharp = fixdenorm(extraSmoothedSharpEnv);
    expr_algo0 = atodb(max(extraSmoothedSharpEnv, 1e-06)); // Evitar log(0)
}

// Algoritmo 1 - Salida en dB con smoothing opcional
expr_algo1 = atodb(max(env_mix_classic, 1e-06));      // Conversión a dB base
if(EXTRA_SMOOTH >= 0.001) {
    extraSmoothedClassicEnv = (extraSmoothHistClassic * extra_smooth_coeff) + (env_mix_classic * ((1 - extra_smooth_coeff)));
    extraSmoothHistClassic = fixdenorm(extraSmoothedClassicEnv);
    expr_algo1 = atodb(max(extraSmoothedClassicEnv, 1e-06));
}

// Algoritmo 2 - Salida en dB con smoothing opcional
expr_algo2 = atodb(max(env_mix_slow, 1e-06));         // Conversión a dB base
if(EXTRA_SMOOTH >= 0.001) {
    extraSmoothedSlowEnv = (extraSmoothHistSlow * extra_smooth_coeff) + (env_mix_slow * ((1 - extra_smooth_coeff)));
    extraSmoothHistSlow = fixdenorm(extraSmoothedSlowEnv);
    expr_algo2 = atodb(max(extraSmoothedSlowEnv, 1e-06));
}

// =============================================================================
// SELECTOR Y MORPHING DE ALGORITMOS - Transición continua sin saltos
// =============================================================================
detector_control = clamp(ALGO, 0, 2);                 // Asegurar rango válido
fade_amount = detector_control - 1;                    // Calcular fade para segunda transición
// Morphing en dos etapas: 0→1 (Sharp↔Classic), 1→2 (Classic↔Slow)
envelope_out = detector_control <= 1 ? mix(expr_algo0, expr_algo1, detector_control) : mix(expr_algo1, expr_algo2, fade_amount);
envelopeDetectorOutput = envelope_out;                 // Salida para debug/monitoring
finalEnvelopeDb = envelopeDetectorOutput;              // Envolvente final en dB

// =============================================================================
// COMPENSACIÓN DE GANANCIA PARA SOLO SIDECHAIN - Evitar saltos abruptos
// =============================================================================
unitaryReference = int(1);                           // Valor de referencia unitario
trimCompensationFactor = unitaryReference / trimGainReference; // Factor de compensación inverso al trim
sidechainTrimCompensated = sidechainDetectionSignal * trimCompensationFactor; // Aplicar compensación de trim
normalizedSidechainSignal = sidechainTrimCompensated; // Señal compensada para monitoreo

// =============================================================================
// PROCESAMIENTO DE SALIDA - Canal Izquierdo
// =============================================================================
// Flujo completo de procesamiento: Compresión → Delta → Auto Makeup →
// Parallel → Dry/Wet → Solo Sidechain → Output Processing → Bypass

// COMPRESIÓN BÁSICA - Aplicar gain reduction calculado
compressionGainReduction = softkneeLinear(finalEnvelopeDb, smoothThresholdDb, smoothRatio, smoothKnee);
gainReductionDb = compressionGainReduction - finalEnvelopeDb;  // Diferencia = reducción real
gainReductionLinear = dbtoa(gainReductionDb);                  // Convertir a factor lineal
compressedLeft = leftDelayedForCompression * gainReductionLinear; // Aplicar compresión

// MODO DELTA - Señal diferencia (experimental)
delta_control = clamp(smoothDeltaMode, 0, 1);                 // Asegurar rango válido
delta_signal = leftDelayedForCompression - compressedLeft;     // Diferencia = lo que se quitó
leftWithDelta = mix(compressedLeft, delta_signal, delta_control); // Mezclar según control

// AUTO MAKEUP - Compensación automática de ganancia (70% del gain reduction)
autoMakeupGainReduction = gainReductionDb;                    // Usar gain reduction como referencia
reduction_smooth_mul = reductionHistLeft * SMOOTH_HISTORY_FACTOR; // Suavizar historia
reduction_current_mul = autoMakeupGainReduction * SMOOTH_PARAM_FACTOR; // Suavizar actual
reduction_smoothed = reduction_current_mul + reduction_smooth_mul; // Combinar suavizado
auto_makeup = reduction_smoothed * AUTO_MAKEUP_FACTOR;        // Aplicar factor -0.7 (70%)
combined_makeup = auto_makeup + leftMakeupGain;               // Combinar con makeup manual
final_makeup_db = mix(leftMakeupGain, combined_makeup, effectiveAutoGain); // Usar effectiveAutoGain (afectado por DELTA)
// Cuando DELTA está activo, forzar makeup a 0dB
finalMakeupDbWithDelta = mix(final_makeup_db, 0, smoothDeltaMode); // 0dB cuando DELTA=1
makeup_linear = dbtoa(finalMakeupDbWithDelta);            // Convertir a factor lineal
leftWithMakeup = leftWithDelta * makeup_linear;               // Aplicar makeup final
reductionHistLeft = fixdenorm(reduction_smoothed);            // Actualizar historia

// COMPRESIÓN PARALELA - Mezcla de señal comprimida con señal original
parallel_control = clamp(effectiveParallelMix, 0, 1);        // Usar effectiveParallelMix (afectado por DELTA)
parallel_compressed = leftWithMakeup * parallel_control;      // Señal comprimida escalada
parallel_mix = leftDelayedForCompression + parallel_compressed; // Sumar original + comprimida
leftParallelMixed = mix(leftWithMakeup, parallel_mix, parallel_control); // Mezclar según control

// MIX DRY/WET - Balance entre señal original y procesada
leftDryWetMixed = mix(leftDelayedForMixing, leftParallelMixed, effectiveDryWetMix); // Usar effectiveDryWetMix (afectado por DELTA)
leftWithSidechain = mix(leftDryWetMixed, sidechainDelayedWrite, smoothSoloSidechain); // Solo sidechain

// OUTPUT PROCESSING - Saturación asimétrica (Off/Soft)
maxOutput = 0.989; // Limitar a -0.1 dBFS (0.989 lineal) para dejar headroom

// ---- LEFT ----
saturationAmount = clamp(smoothSoftclip, 0, 1);                  // Cantidad de saturación (0=Off, 1=Full)
// Cuando DELTA está activo, bypasear también el softclipping
effectiveSaturationAmount = mix(saturationAmount, 0, smoothDeltaMode); // 0 cuando DELTA=1
// Que la saturación solo actúe en la cadena WET
effectiveSaturationAmount = effectiveSaturationAmount * effectiveDryWetMix;
effectiveSaturationAmount = clamp(effectiveSaturationAmount, 0, 1);

// Saturación asimétrica para añadir color/calidez
leftSaturated = 0;  // Declarar variable
if(leftWithSidechain > 0) {
    // Semiciclo positivo - más saturación (genera armónicos pares)
    leftSaturated = tanh(leftWithSidechain * 1.2) * 0.833;   // Compensar ganancia
}
else {
    // Semiciclo negativo - menos saturación
    leftSaturated = tanh(leftWithSidechain * 0.8) * 1.25;    // Compensar ganancia
}
leftSaturated = clamp(leftSaturated, -maxOutput, maxOutput);

// Mezclar señal original con saturada según el parámetro
leftProcessedOutput = mix(leftWithSidechain, leftSaturated, effectiveSaturationAmount);
leftFinalOutput = mix(leftDelayedForMixing, leftProcessedOutput, smoothBypassAmount); // Bypass final
out1 = leftFinalOutput;                                       // Salida canal izquierdo

// =============================================================================
// PROCESAMIENTO DE SALIDA - Canal Derecho
// =============================================================================
// Idéntico al canal izquierdo pero con variables propias para claridad.

// COMPRESIÓN BÁSICA - Aplicar gain reduction calculado (compartido entre canales)
rightGainReductionDb = compressionGainReduction - finalEnvelopeDb; // Misma reducción que L
rightGainReductionLinear = dbtoa(rightGainReductionDb);             // Convertir a factor lineal
compressedRight = rightDelayedForCompression * rightGainReductionLinear; // Aplicar compresión

// MODO DELTA - Señal diferencia (experimental)
rightDeltaControl = clamp(smoothDeltaMode, 0, 1);               // Asegurar rango válido
rightDeltaSignal = rightDelayedForCompression - compressedRight; // Diferencia = lo que se quitó
rightWithDelta = mix(compressedRight, rightDeltaSignal, rightDeltaControl); // Mezclar según control

// AUTO MAKEUP - Compensación automática de ganancia (70% del gain reduction)
rightAutoMakeupGainReduction = rightGainReductionDb;              // Usar gain reduction como referencia
rightReductionSmoothMul = reductionHistRight * SMOOTH_HISTORY_FACTOR; // Suavizar historia
rightReductionCurrentMul = rightAutoMakeupGainReduction * SMOOTH_PARAM_FACTOR; // Suavizar actual
rightReductionSmoothed = rightReductionCurrentMul + rightReductionSmoothMul; // Combinar suavizado
rightAutoMakeup = rightReductionSmoothed * AUTO_MAKEUP_FACTOR;    // Aplicar factor -0.7 (70%)
rightCombinedMakeup = rightAutoMakeup + rightMakeupGain;          // Combinar con makeup manual
rightFinalMakeupDb = mix(rightMakeupGain, rightCombinedMakeup, effectiveAutoGain); // Usar effectiveAutoGain
// Cuando DELTA está activo, forzar makeup a 0dB
rightFinalMakeupDbWithDelta = mix(rightFinalMakeupDb, 0, smoothDeltaMode); // 0dB cuando DELTA=1
rightMakeupLinear = dbtoa(rightFinalMakeupDbWithDelta);         // Convertir a factor lineal
rightWithMakeup = rightWithDelta * rightMakeupLinear;             // Aplicar makeup final
reductionHistRight = fixdenorm(rightReductionSmoothed);           // Actualizar historia

// COMPRESIÓN PARALELA - Mezcla de señal comprimida con señal original
rightParallelControl = clamp(effectiveParallelMix, 0, 1);        // Usar effectiveParallelMix
rightParallelCompressed = rightWithMakeup * rightParallelControl; // Señal comprimida escalada
rightParallelMix = rightDelayedForCompression + rightParallelCompressed; // Sumar original + comprimida
rightParallelMixed = mix(rightWithMakeup, rightParallelMix, rightParallelControl); // Mezclar según control

// MIX DRY/WET - Balance entre señal original y procesada
rightDryWetMixed = mix(rightDelayedForMixing, rightParallelMixed, effectiveDryWetMix); // Usar effectiveDryWetMix
rightWithSidechain = mix(rightDryWetMixed, sidechainDelayedTap, smoothSoloSidechain); // Solo sidechain

// OUTPUT PROCESSING - Saturación asimétrica (Off/Soft)
rightSaturationAmount = clamp(smoothSoftclip, 0, 1);             // Cantidad de saturación (0=Off, 1=Full)
// Cuando DELTA está activo, bypasear también el softclipping
rightEffectiveSaturationAmount = mix(rightSaturationAmount, 0, smoothDeltaMode); // 0 cuando DELTA=1
// De nuevo que la saturación sólo actúe en la parte WET
rightEffectiveSaturationAmount = rightEffectiveSaturationAmount * effectiveDryWetMix * (1 - smoothSoloSidechain);
rightEffectiveSaturationAmount = clamp(rightEffectiveSaturationAmount, 0, 1);

// Saturación asimétrica para añadir color/calidez
rightSaturated = 0;  // Declarar variable
if(rightWithSidechain > 0) {
    // Semiciclo positivo - más saturación (genera armónicos pares)
    rightSaturated = tanh(rightWithSidechain * 1.2) * 0.833;  // Compensar ganancia
}
else {
    // Semiciclo negativo - menos saturación
    rightSaturated = tanh(rightWithSidechain * 0.8) * 1.25;   // Compensar ganancia
}
rightSaturated = clamp(rightSaturated, -maxOutput, maxOutput);

// Mezclar señal original con saturada según el parámetro
rightProcessedOutput = mix(rightWithSidechain, rightSaturated, rightEffectiveSaturationAmount);
rightFinalOutput = mix(rightDelayedForMixing, rightProcessedOutput, smoothBypassAmount); // Bypass final
out2 = rightFinalOutput;                                      // Salida canal derecho

// =============================================================================
// GAIN REDUCTION OUTPUT - Medidor de compresión para UI
// =============================================================================
// Genera señal de monitoreo para el medidor de gain reduction en la interfaz.
// Mezcla entre valor unitario (sin compresión) y gain reduction real según bypass.

gainReductionMeter = mix(unitaryReference, rightGainReductionLinear, bypassInverted); // 1=activo, 0=bypass
gainReductionOutput = min(gainReductionMeter, 1);              // Limitar a máximo 1.0
out3 = gainReductionOutput;                                    // Salida para medidor GR

// =============================================================================
// ACTUALIZACIÓN DE HISTORIAS PARA EL SIGUIENTE CICLO
// =============================================================================
// Todas las historias se actualizan al final del ciclo de procesamiento

// Historias de smoothing de parámetros
parallelMixHistory = parallelMixHistoryNext;
deltaModeHistory = deltaModeHistoryNext;
autoGainHistory = autoGainHistoryNext;
thresholdHistory = thresholdHistoryNext;
makeupGainHistory = makeupGainHistoryNext;
soloSidechainHistory = soloSidechainHistoryNext;
bypassAmountHistory = bypassAmountHistoryNext;
keyMixHistory = keyMixHistoryNext;
dryWetMixHistory = dryWetMixHistoryNext;
trimHistory = trimHistoryNext;
sidechainTrimHistory = sidechainTrimHistoryNext;

// Historias adicionales de smoothing
ratioHistory = ratioHistoryNext;
kneeHistory = kneeHistoryNext;
reactHistory = reactHistoryNext;
smoothAmountHistory = smoothAmountHistoryNext;
lookaheadHistory = lookaheadHistoryNext;
hpfFreqHistory = hpfFreqHistoryNext;
lpfFreqHistory = lpfFreqHistoryNext;
scEnableHistory = scEnableHistoryNext;
softclipHistory = softclipHistoryNext;
atkHistory = atkHistoryNext;
relHistory = relHistoryNext;

// Historias de filtros
lpfHistory1 = lpfHistory1Next;
lpfHistory2 = lpfHistory2Next;
lpfHistory3 = lpfHistory3Next;
lpfHistory4 = lpfHistory4Next;
lpfHistory5 = lpfHistory5Next;
lpfHistory6 = lpfHistory6Next;
lpfHistory7 = lpfHistory7Next;
lpfHistory8 = lpfHistory8Next;
hpfHistory1 = hpfHistory1Next;
hpfHistory2 = hpfHistory2Next;
hpfHistory3 = hpfHistory3Next;
hpfHistory4 = hpfHistory4Next;
hpfHistory5 = hpfHistory5Next;
hpfHistory6 = hpfHistory6Next;
hpfHistory7 = hpfHistory7Next;
hpfHistory8 = hpfHistory8Next;
hpfOrderHistory = hpfOrderHistoryNext;
lpfOrderHistory = lpfOrderHistoryNext;

// Delays de lookahead (escritura para el siguiente ciclo)
sidechainWriteDelay.write(normalizedSidechainSignal);
sidechainTapDelay.write(normalizedSidechainSignal);
// Las escrituras de leftOutputDelay y rightOutputDelay se hacen ahora arriba con el trim